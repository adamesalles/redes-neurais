def sgd(X, y, lr=0.01, epochs=100, shuffle=True):
    n, p = X.shape
    theta = np.zeros(p)
    costs = []

    for epoch in range(epochs):
        # Embaralhar dados
        if shuffle:
            indices = np.random.permutation(n)
            X_epoch = X[indices]
            y_epoch = y[indices]
        else:
            X_epoch, y_epoch = X, y

        # Iterar sobre cada amostra
        for i in range(n):
            # Uma amostra por vez
            xi = X_epoch[i:i+1]
            yi = y_epoch[i]

            # Gradiente da amostra i
            pred_i = xi @ theta
            grad_i = xi.T @ (pred_i - yi)

            # Atualização
            theta = theta - lr * grad_i.flatten()

        # Calcular custo total
        cost = 0.5 * np.mean((y - X @ theta)**2)
        costs.append(cost)

    return theta, costs
